import { EBCDICEncoding } from './types';
import { validateInput, validateEncoding } from './validators';

export class EBCDICParser {
  private static readonly EBCDIC_TO_ASCII: { [key: number]: number } = {
    // Control Characters
    0x00: 0x00, // Null
    0x0C: 0x0C, // Form Feed
    0x15: 0x0A, // New Line
    0x25: 0x0D, // Carriage Return
    
    // Special Characters
    0x40: 0x20, // Space
    0x4A: 0x0A, // Line Feed
    0x4B: 0x2E, // .
    0x4C: 0x3C, // <
    0x4D: 0x28, // (
    0x4E: 0x2B, // +
    0x4F: 0x7C, // |
    0x50: 0x26, // &
    0x5A: 0x5D, // ]
    0x5B: 0x24, // $
    0x5C: 0x2A, // *
    0x5D: 0x29, // )
    0x5E: 0x3B, // ;
    0x5F: 0x5E, // ^
    0x60: 0x2D, // -
    0x61: 0x2F, // /
    0x6B: 0x2C, // ,
    0x6C: 0x25, // %
    0x6D: 0x5F, // _
    0x6E: 0x3E, // >
    0x6F: 0x3F, // ?
    0x79: 0x60, // `
    0x7A: 0x3A, // :
    0x7B: 0x23, // #
    0x7C: 0x40, // @
    0x7D: 0x27, // '
    0x7E: 0x3D, // =
    0x7F: 0x22, // "
    0xA1: 0x7E, // ~
    0xAD: 0x5B, // [
    0xC0: 0x7B, // {
    0xD0: 0x7D, // }
    0xE0: 0x5C, // \

    // Numbers
    0xF0: 0x30, // 0
    0xF1: 0x31, // 1
    0xF2: 0x32, // 2
    0xF3: 0x33, // 3
    0xF4: 0x34, // 4
    0xF5: 0x35, // 5
    0xF6: 0x36, // 6
    0xF7: 0x37, // 7
    0xF8: 0x38, // 8
    0xF9: 0x39, // 9

    // Uppercase Letters
    0xC1: 0x41, // A
    0xC2: 0x42, // B
    0xC3: 0x43, // C
    0xC4: 0x44, // D
    0xC5: 0x45, // E
    0xC6: 0x46, // F
    0xC7: 0x47, // G
    0xC8: 0x48, // H
    0xC9: 0x49, // I
    0xD1: 0x4A, // J
    0xD2: 0x4B, // K
    0xD3: 0x4C, // L
    0xD4: 0x4D, // M
    0xD5: 0x4E, // N
    0xD6: 0x4F, // O
    0xD7: 0x50, // P
    0xD8: 0x51, // Q
    0xD9: 0x52, // R
    0xE2: 0x53, // S
    0xE3: 0x54, // T
    0xE4: 0x55, // U
    0xE5: 0x56, // V
    0xE6: 0x57, // W
    0xE7: 0x58, // X
    0xE8: 0x59, // Y
    0xE9: 0x5A, // Z

    // Lowercase Letters
    0x81: 0x61, // a
    0x82: 0x62, // b
    0x83: 0x63, // c
    0x84: 0x64, // d
    0x85: 0x65, // e
    0x86: 0x66, // f
    0x87: 0x67, // g
    0x88: 0x68, // h
    0x89: 0x69, // i
    0x91: 0x6A, // j
    0x92: 0x6B, // k
    0x93: 0x6C, // l
    0x94: 0x6D, // m
    0x95: 0x6E, // n
    0x96: 0x6F, // o
    0x97: 0x70, // p
    0x98: 0x71, // q
    0x99: 0x72, // r
    0xA2: 0x73, // s
    0xA3: 0x74, // t
    0xA4: 0x75, // u
    0xA5: 0x76, // v
    0xA6: 0x77, // w
    0xA7: 0x78, // x
    0xA8: 0x79, // y
    0xA9: 0x7A  // z
  };

  /**
   * Converts EBCDIC encoded data to the specified output encoding
   * @param input - Buffer containing EBCDIC encoded data
   * @param outputEncoding - Desired output encoding (UTF-8 or ASCII)
   * @returns Buffer containing the converted data
   */
  public static convert(input: Buffer, outputEncoding: EBCDICEncoding): Buffer {
    validateInput(input);
    validateEncoding(outputEncoding);

    const outputBuffer = Buffer.alloc(input.length);
    
    for (let i = 0; i < input.length; i++) {
      const ebcdicByte = input[i];
      const asciiByte = this.EBCDIC_TO_ASCII[ebcdicByte] || ebcdicByte;
      outputBuffer[i] = asciiByte;
    }

    return outputBuffer;
  }

  /**
   * Converts a file from EBCDIC to the specified encoding
   * @param filePath - Path to the EBCDIC encoded file
   * @param outputEncoding - Desired output encoding (UTF-8 or ASCII)
   * @returns Promise<Buffer> containing the converted data
   */
  public static async convertFile(filePath: string, outputEncoding: EBCDICEncoding): Promise<Buffer> {
    const fs = await import('fs/promises');
    const fileBuffer = await fs.readFile(filePath);
    return this.convert(fileBuffer, outputEncoding);
  }
} 